\documentclass[xcolor=dvipsnames]{beamer}
%\usepackage[OT4]{fontenc}
%\usepackage[utf8]{inputenc}
%\usepackage[polish]{babel}
\usepackage{fancyvrb}
\usepackage{thumbpdf}
\usepackage{relsize}
\usepackage{amsmath}

%\usetheme[left]{Marburg}
%\usetheme{Hannower}
\useinnertheme[shadow]{rounded}
\useoutertheme[right,width=2cm,hideothersubsections]{sidebar}
%\usecolortheme{albatross}
\usecolortheme{crane}
%\setbeamercolor{structure}{fg=OliveGreen!50!black}
%\usecolortheme[named=OliveGreen]{structure}
\usefonttheme{default}
\setbeamercovered{transparent}
\title{Scala -- functional programming for JVM}
\author{Jacek~Bilski}
\date{\today}
\subject{Scala -- functional programming for JVM}

\setbeamertemplate{navigation symbols}
{
	\usebeamercolor[fg]{navigation symbols dimmed}
	{
		\insertframenumber\,/\,\inserttotalframenumber
	}
}

\begin{document}

\begin{frame}
\titlepage
\end{frame}

\begin{frame}
\frametitle{Agenda}
\tableofcontents[pausesections]
\end{frame}

\section{Introduction}

\begin{frame}
\frametitle{Scala}
\begin{itemize}
\item \href{http://www.scala-lang.org/}{http://www.scala-lang.org/}
\item Yet another language for JVM
\item Both object-oriented and functional language
\item Scala is statically typed, strongly type-inferring
\end{itemize}
\end{frame}

\section{Hello world!}

\frame[containsverbatim]{
\frametitle{Hello World!}
\begin{Verbatim}[obeytabs=true,fontsize=\relscale{0.7},tabsize=2]
package com.zooplus.jacekb.learningTime.scala

object Hello {
	def main(args: Array[String]) = println("Hello World!")
}
\end{Verbatim}
}

\begin{frame}
\frametitle{Hello World explained}
$def\:f(x:\:Int) = x * x$
\begin{itemize}
\item One method defined (Scalas' equivalent of Javas' $main$ method), which just prints the usual ''Hello World!''.
\item No semicolon at the end, we don't need them.
\item no ''return'' keyword, value of last expression is the functions' result.
\item Hello is an object, not a class. It's a singleton with all methods ''static''. There are no ''static'' methods in Scala, you define a class and object with the same name.
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Hello World explained -- defining functions}
\begin{itemize}
\item We define functions with: $def\:functionName$,
\item then we add some parameters: $def\:f(x:\:Type)$,
\item then we may (it's necessary only for recursive functions) define returned type: $def\:f(x:\:Int):\:Int$,
\item then we define functions body: $x * x$ (we can omit parenthesis, because the body is a proper Scala expression).
\item In total: $def\:f(x:\:Int) = x * x$.
\end{itemize}
\end{frame}


\section{Theory}

\begin{frame}
\frametitle{Functional programming}
\begin{itemize}
\item Based on lambda calculus, formal system created to support formal studies of computations.
\item Basic elements are variables, binding and functions.
\item Functional programming is a paradigm that treats computation as the evaluation of mathematical functions and avoids state and mutable data.
\item Functions are first-class citizens, can be passed around, even as parameters or results of other functions (higher-order functions).
\item In pure form it very closely resembles solving mathematical problems.
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Pure functions}
\begin{itemize}
\item Pure functions have no ''side effects'', they don't change anything in memory or do I/O operations.
\item This means, that pure function called with the same parameters will always return the same result. We may cache it's result.
\item If there's no data dependency between two pure functions, we can run them in different order and/or in parallel. When smartly used one can use multiple CPUs to fasten computation.
\item Functions are first-class citizens, can be passed around, even as parameters or results of other functions (higher-order functions).
\item In pure form it very closely resembles solving mathematical problems.
\end{itemize}
\end{frame}

\section{Examples}

\frame[containsverbatim]{
\frametitle{''Variables''}
\begin{Verbatim}[obeytabs=true,fontsize=\relscale{0.7},tabsize=2]
object Hello {
	def main(args: Array[String]) = println(f(4))

	def f(x: Int) {
		var y = x - 1	// mutable, can reassign
		y = 2 * y	// allowed, because it's var
		val z = x + 1	// immutable, not re-assignable, constant
		z = 2 * z	// compilation error
		x + y + z
	}
}
\end{Verbatim}
}

\frame[containsverbatim]{
\frametitle{Pattern Matching -- switch on steroids}
\begin{Verbatim}[obeytabs=true,fontsize=\relscale{0.7},tabsize=2]
object PatternMatching {
	case class A(s: String)
	case class B(i: Int)

	def main(args: Array[String]) {
		f(A("abc"))	// "Got string: abc"
		f(B(3))		// "Got int: 3"
		f(1.5)		// Exception in thread "main"
		// scala.MatchError: 1.5 (of class java.lang.Double)
	}

	def f(x: Any) {	// Any is the root of the Scala class hierarchy
		x match {
			case A(s) => println("Got string: " + s)
			case B(i) => println("Got int: " + i)
		}
	}
}
\end{Verbatim}
}

\frame[containsverbatim]{
\frametitle{Higher order functions}
\begin{Verbatim}[obeytabs=true,fontsize=\relscale{0.7},tabsize=2]
object HigherOrderFunctions {

	def main(args: Array[String]) = f(3)

	def f(x: Int) = {
		// legal, function is an object
		def h(x: Int) = 2 * x

		// 0-parameter function returning function
		def u: Int => Int = h

		// passing function to function
		// u is at first evaluated into another function
		g(x, u)
	}

	// t is a function getting an Int and returning an Int
	def g(x: Int, t: Int => Int) = t(x)
}
\end{Verbatim}
}

\frame[containsverbatim]{
\frametitle{Tail recursion}
\begin{Verbatim}[obeytabs=true,fontsize=\relscale{0.6},tabsize=2]
object TailRecursion {

	def main(args: Array[String]) {
		println("g: " + g(1000000000))	// "g: 1000000000"
		println("f: " + f(1000000000))	// StackOverflowError
	}

	def f(x: Int): Int = {
		if (x > 0) {
			// return call to itself plus one additional operation
			1 + f(x - 1)
		} else {
			0
		}
	}

	def g(x: Int): Int = {
		def t(x: Int, acc: Int): Int = {
			if (x > 0) {
				// return call to itself without any other operations
				t(x - 1, acc + 1)
			} else {
				acc
			}
		}
		t(x, 0)
	}
}
\end{Verbatim}
}

\frame[containsverbatim]{
\frametitle{Quiz -- val, def and lazy}
\begin{Verbatim}[obeytabs=true,fontsize=\relscale{0.6},tabsize=2]
object ValDefAndLazy {

	def main(args: Array[String]) = {
		println("a")
		println("x: " + x)
		println("y: " + y)
		println("z: " + z)
		println("x: " + x)
		println("y: " + y)
		println("z: " + z)
	}

	val x = {
		println("Calculating x")
		1000
	}

	def y = {
		println("Calculating y")
		2000
	}

	lazy val z = {
		println("Calculating z")
		3000
	}
}
\end{Verbatim}
}

\begin{frame}
\frametitle{Answer:}
xa1y2z31y23b
\end{frame}


% chaining operations on collections - map/reduce
% traits and mixins
% "anonymous" (_) values
% syntax without . - DSLs
% Streams ?


\section{Questions?}

\begin{frame}
\frametitle{Questions?}
\begin{center}
\Huge{?}
\end{center}
\end{frame}


\end{document}
